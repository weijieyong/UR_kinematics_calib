# UR_kinematics_calib

High-accuracy Python FK & IK solver for UR5 with calibrated DH parameters.

## Overview

This project provides both Python implementations for forward kinematics (FK) and inverse kinematics (IK) solvers optimized for UR5 robots using calibrated DH parameters. It features high-performance C++ algorithms([QuIK](https://github.com/weijieyong/quik)) with Python bindings for ease of use.

## Features

- **High Accuracy**: Position error < 0.08mm, rotation error < 0.032°
- **Ultra-Fast Performance**: IK: 0.017ms, FK: 0.0007ms (on Intel i9-14900K)
- **Calibrated Parameters**: Uses actual robot calibration data for improved accuracy
- **C++/Python Hybrid**: High-performance C++ core with convenient Python interface

---

## Installation

### Clone the Repository

```bash
# Clone with submodules (recommended)
git clone --recurse-submodules https://github.com/weijieyong/UR_kinematics_calib.git

# If you cloned without --recurse-submodules
git submodule update --init --recursive
```

### Option 1: Using Docker (Recommended)

```bash
# Build the Docker image
docker build -t ur-kinematics-calib .

# Run the container interactively
docker run -it --rm -v ${PWD}:/app ur-kinematics-calib
```

### Option 2: Install with uv locally

The project uses [uv](https://github.com/astral-sh/uv) for dependency management:

```bash
# Install uv
pip install uv

# Install dependencies and build C++ components and run scripts
uv run <Python-script.py> 
```

> [!NOTE]  
> When using `uv run ...`, it will create a .venv directory and install all required dependencies automatically.

### Dependencies

- Python 3.12+
- CMake 3.15+
- C++17 compatible compiler
- uv

---

## Usage Examples

### Quick Start Demo

```bash
# Run the basic IK demo
uv run scripts/basic_quik_demo.py
```

### Forward Kinematics (FK)

```bash
# Calculate end-effector pose from joint angles (in degrees)
uv run scripts/fk_demo.py -j 1.54,-28.43,24.41,-130.54,-37.17,-147.01
```

### Inverse Kinematics (IK)

```bash
# Calculate joint angles from end-effector pose (x,y,z,rx,ry,rz)
uv run scripts/ik_demo.py -p 159.13,-317.1,413.36,1.266,-3.32,-0.283
# or
uv run scripts/ik_demo.py -p="159.13,-317.1,413.36,1.266,-3.32,-0.28"
```

### Validation Tools

```bash
# Batch validate FK->IK roundtrip
uv run scripts/batch_fk_ik.py -n 10000 -ro 0.1 -q

# Validate FK->IK roundtrip
uv run scripts/fk_ik_check.py -j 31.64,-117.58,104.85,-77.19,-82.32,-58.4

# Run all tests
uv run tests/run_all_tests.py

# Compare calculated FK with actual robot data
uv run tests/dry_parse.py --compare 1.54,-28.43,24.41,-130.54,-37.17,-147.01,-872.69,-236.61,417.99,1.344,-1.557,0.494
```

> [!TIP]  
> Command Arguments: (use `--help` for more details)  
> - `fk_demo.py -j <deg1,deg2,deg3,deg4,deg5,deg6>`  
> - `ik_demo.py -p <x,y,z,rx,ry,rz>`  
> - `fk_ik_check.py -j <deg1,deg2,deg3,deg4,deg5,deg6>`
> - `batch_fk_ik.py -ro 0.5 -n 1000 -q` (offset for initial guess, num-test, quiet(suppress logging)) 


#### Notes for development
```bash
# Rebuild if C++ source files were modified
uv run --reinstall scripts/binding_usage.py
```

---

## Performance Metrics

### QuIK C++ Implementation (Intel i9-14900K)
- **IK Solving**: 0.0170 ms average (~58,824 iterations/second)
- **FK Solving**: 0.0007 ms average (~1,428,571 iterations/second)
- **Speed Improvement**: 200x faster IK, 4x faster FK compared to Python

### Accuracy

FK with calibrated DH parameters
- **Position error**: < 0.08 mm
  - Range: 0.0169 mm to 0.0800 mm
- **Rotation error**: < 0.032°
  - Range: 0.0119° to 0.0317°

---

## Implementation Status

### Current Capabilities
- Integrated [QuIK](https://github.com/weijieyong/quik) C++ library with Python bindings for high-performance FK and IK.
- Analytical IK used for initial guess generation to improve QuIK's convergence.
- Calibration data integration for improved accuracy.
- Python implementations for FK and IK solvers.

### Current Limitations
- Numerical IK solver (QuIK) may converge to local minima, though an analytical initial guess helps mitigate this.
- IK results can still depend on the initial joint configuration guess in challenging scenarios.
- May produce suboptimal solutions in certain edge-case configurations. (*still exploring this*)

### Future Roadmap
- [ ] Conduct more extensive testing to identify limitations and ensure robustness across a wider range of configurations.
- [ ] Explore further enhancements for IK solution stability and optimality.
- [ ] Potentially expand support for other UR robot models.

### Research Resources
- [Analytical IK Research Summary](docs/Summary-Deep-Research.pdf) - Investigation into analytical IK approaches for calibrated parameters. *(generated by ChatGPT, some info might be subject to verification)*

---

## Project Structure

```
ur_kinematics_calib/
├── configs/             # calibration and UR control files
├── cpp/                 # C++ source for Python bindings
│   └── quik_bind/       # QuIK library Python bindings
├── data/                # UR capture data (joint angles & EEF poses)
│   └── joint-eef-data.csv
├── docs/                # Documentation and plans
│   ├── PLAN.md
│   └── Summary-Deep-Research.pdf
├── scripts/             # Demo and utility scripts
│   ├── basic_quik_demo.py
│   ├── batch_fk_ik.py
│   ├── benchmark_fk.py
│   ├── benchmark_ik.py
│   ├── binding_usage.py
│   ├── fk_demo.py
│   ├── fk_ik_check.py
│   ├── ik_convergence_demo.py
│   ├── ik_demo.py
│   ├── round_trip_test.py
│   └── test_analytic_ik.py
├── src/                 # Package source
│   └── ur_kinematics_calib/
│       ├── __init__.py
│       ├── fk.py
│       ├── ik.py
│       └── util.py
├── tests/               # Test scripts and utilities
│   ├── test_fk.py
│   ├── test_ik.py
│   └── test_util.py
├── thirdparty/          # Third-party libraries
│   └── quik/            # QuIK C++ library submodule
└── uv.lock              # uv lock file
```

## License

[MIT License](LICENSE)

