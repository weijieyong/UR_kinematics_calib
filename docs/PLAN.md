### Comprehensive Pre-Implementation Checklist

*(for a high-accuracy Python FK & IK solver on a calibrated UR5 arm)*

| Phase                                     | Key Considerations                                                                                                                                                                                                                                              | Why It Matters / Action Items                                              |                                                                                                                                                                                                      |                                                                |
| ----------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------- |
| **1. Project Scope & Success Criteria**   | • Define maximum allowable pose error (e.g., ≤0.2 mm / 0.05 °) when compared to UR controller. <br>• List supported features (analytic IK, numerical refinement, singularity handling, external TCP offsets, etc.).                                             | Establishes clear acceptance tests and prevents “scope creep.”             |                                                                                                                                                                                                      |                                                                |
| **2. File I/O & Data Integrity**          | • Confirm **file encoding** and line-ending variants. <br>• Write robust parsers for `[DH]` and `[mounting]` sections. <br>• Verify YAML/INI comments are stripped safely. <br>• Validate checksums & `calibration_status == 2` (linearised) before use.        | Bad parses or an un-linearised robot corrupt every downstream calculation. |                                                                                                                                                                                                      |                                                                |
| **3. Units & Conventions**                | • Nominal DH *d* & *a* in **metres**; confirm calibration deltas are in the same units (large `delta_d ≈ ±200 mm` is plausible). <br>• Angles in **radians**; joint value directions per `joint_direction`. <br>• UR’s base frame (Z-up) vs. application frame. | Silent unit mismatches are the #1 root-cause of multi-millimetre errors.   |                                                                                                                                                                                                      |                                                                |
| **4. Calibrated Parameter Fusion**        | • Compute effective DH sets:   `aᵢ_eff = aᵢ + δaᵢ, …`. <br>• Apply **joint home offsets** and **raw encoder offsets** to align zero positions. <br>• Detect & log **outlier deltas** (>5 % of nominal link length).                                             | Ensures the solver models *your* robot, not the catalogue figure.          |                                                                                                                                                                                                      |                                                                |
| **5. Numerical Precision & Data Types**   | • Use `numpy.float64`; prohibit float32 truncation. <br>• Vectorise trig functions to avoid cumulative rounding. <br>• Guard near-zero denominators with `np.finfo(float).eps`.                                                                                 | Millimetre-level accuracy demands 1e-9 rad precision in some joints.       |                                                                                                                                                                                                      |                                                                |
| **6. Kinematic Model Architecture**       | • Implement a clean forward-chain API: `T = fk(q)`; guarantee differentiability for numerical IK. <br>• Allow **base-tool transforms** injection (end-effectors, force-torque sensors). <br>• Separate geometric model from joint-limit safety model.           | Modular design simplifies later additions like collision checks.           |                                                                                                                                                                                                      |                                                                |
| **7. IK Algorithm Strategy**              | • Primary: closed-form analytic for UR5 (8 solutions). <br>• Secondary: damped-least-squares numerical refinement for redundancy resolution. <br>• Solution ranking: pick nearest to seed, obey joint limits, avoid elbow-flip.                                 | Hybrid analytic + numeric gives both speed and robustness.                 |                                                                                                                                                                                                      |                                                                |
| **8. Handling Singularities & Large Δd**  | • Detect elbow & wrist singularities (                                                                                                                                                                                                                          | sin θ₅                                                                     | < ε). <br>• For extreme calibrated `Δd`, re-derive analytic equations with symbolic tool (e.g., SymPy) to keep terms well-conditioned. <br>• Fallback to numerical IK when conditioning number >10⁵. | Prevents solver blow-ups when δ parameters skew link geometry. |
| **9. Joint Limits, Velocity & Direction** | • Incorporate UR5 joint ranges and `joint_direction` signs. <br>• Normalise returned angles to (-π, π] or \[0, 2π) consistently.                                                                                                                                | Ensures controller-comparability and avoids wrist “wrap.”                  |                                                                                                                                                                                                      |                                                                |
| **10. Validation Plan**                   | • Create **golden test set** of 30–50 poses logged from the real controller (TCP + joint state). <br>• Automate RMS error metrics, max error, and pass/fail gating. <br>• Include edge cases near singularities & workspace limits.                             | Objective yard-stick before deployment.                                    |                                                                                                                                                                                                      |                                                                |
| **11. Performance & Runtime**             | • Target <1 ms FK, <2 ms analytic IK on modern CPU. <br>• Benchmark with Python’s `time.perf_counter()`; profile hotspots (Numba, Cython if needed).                                                                                                            | Real-time planners typically need ≥250 Hz update cycles.                   |                                                                                                                                                                                                      |                                                                |
| **12. Software Quality & Tooling**        | • 100 % unit-test coverage of math kernels. <br>• Use `ruff` or `flake8`; type-hint with `typing` + `mypy`. <br>• Set up CI (GitHub Actions) running on multiple Python versions.                                                                               | Catches regressions early; enforces reproducibility.                       |                                                                                                                                                                                                      |                                                                |
| **13. Documentation & Traceability**      | • Auto-generate API docs (Sphinx / pdoc). <br>• Include derivation appendix mapping each DH index to UR joint names.                                                                                                                                            | Makes audit & maintenance practical six months later.                      |                                                                                                                                                                                                      |                                                                |
| **14. Safety & Deployment Hooks**         | • Add optional saturation layer to enforce joint-speed limits before command publishing. <br>• Log warnings when solver returns a pose outside calibrated workspace.                                                                                            | Protects hardware during closed-loop experiments.                          |                                                                                                                                                                                                      |                                                                |
| **15. Future-Proofing**                   | • Design parameter loaders to accept updated calibration files without code changes. <br>• Abstract DH convention so a modified solver can ingest modified‐Denavit–Hartenberg (MDH) if UR changes spec.                                                         | Minimises rework when a new robot variant arrives.                         |                                                                                                                                                                                                      |                                                                |

**Final Sanity Step**
Before writing a single line of solver code, run a *dry-parse* script that:

1. **Reads both files** with full precision.
2. **Combines** nominal + deltas → effective parameters.
3. **Computes FK of `q_home_offset`**, printing TCP pose.
4. **Queries the real controller at home** and compares.

If the mismatch > goal tolerance, resolve it **now**—otherwise every later effort will chase the wrong baseline.
